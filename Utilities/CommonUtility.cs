// <auto-generated/> - Added to exclude style cop
#region Included namespaces
using Microsoft.AspNetCore.Http;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
#endregion

namespace Utilities
{
    /// <summary>
    /// Common Utility
    /// </summary>
    public static class CommonUtility
    {
        #region Variables
        /// <summary>
        /// EncryptionKey
        /// </summary>
        private const string DefaultEncryptionKey = "LetAgreeSecureKey";

        /// <summary>
        /// Size of salt.
        /// </summary>
        private const int SaltSize = 16;

        /// <summary>
        /// Size of hash.
        /// </summary>
        private const int HashSize = 20;
        #endregion Variables

        #region GetDateInFormat
        /// <summary>
        /// Get Date In Format
        /// </summary>
        /// <param name="dateTime"></param>
        /// <returns></returns>
        public static string GetDateInFormat(this DateTime dateTime)
        {
            string format = "dd/MMM/yyyy HH:mm:ss";

            return dateTime.ToString(format, CultureInfo.InvariantCulture);
        }
        #endregion GetDateInFormat

        #region GetDateInFormatForFileName
        /// <summary>
        /// GetDateInFormatForFileName
        /// </summary>
        /// <param name="dateTime"></param>
        /// <returns></returns>
        public static string GetDateInFormatForFileName(this DateTime dateTime)
        {
            string format = "dd_MM_yyyy_HH_mm_ss_fff";

            return dateTime.ToString(format, CultureInfo.InvariantCulture);
        }
        #endregion GetDateInFormatForFileName

        #region Decrypt
        /// <summary>
        /// decrypt
        /// </summary>
        /// <param name="textToDecrypt"></param>
        /// <returns></returns>
        public static string Decrypt(this string textToDecrypt)
        {
            if (!string.IsNullOrEmpty(textToDecrypt))
            {
                try
                {
                    textToDecrypt = textToDecrypt.Replace(' ', '+').Replace('_', '+').Replace('@', '=').Replace('$', '/');

                    byte[] Results;
                    UTF8Encoding UTF8 = new UTF8Encoding();
                    MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
                    byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(DefaultEncryptionKey));
                    TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider
                    {
                        Key = TDESKey,
                        Mode = CipherMode.ECB,
                        Padding = PaddingMode.PKCS7
                    };
                    byte[] DataToDecrypt = Convert.FromBase64String(textToDecrypt);
                    try
                    {
                        ICryptoTransform Decryptor = TDESAlgorithm.CreateDecryptor();
                        Results = Decryptor.TransformFinalBlock(DataToDecrypt, 0, DataToDecrypt.Length);
                    }
                    catch (Exception)
                    {
                        throw;
                    }
                    finally
                    {
                        TDESAlgorithm.Clear();
                        HashProvider.Clear();
                        TDESAlgorithm.Dispose();
                        HashProvider.Dispose();
                    }

                    return UTF8.GetString(Results);
                }
                catch (Exception)
                {
                    throw;
                }
            }
            else
            {
                return string.Empty;
            }
        }
        #endregion Decrypt

        #region Encrypt
        /// <summary>
        /// Encrypt
        /// </summary>
        /// <param name="textToEncrypt"></param>
        /// <returns></returns>
        public static string Encrypt(this string textToEncrypt)
        {
            byte[] Results;
            UTF8Encoding UTF8 = new UTF8Encoding();
            MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
            byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(DefaultEncryptionKey));
            TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider
            {
                Key = TDESKey,
                Mode = CipherMode.ECB,
                Padding = PaddingMode.PKCS7
            };
            byte[] DataToEncrypt = UTF8.GetBytes(textToEncrypt);
            try
            {
                ICryptoTransform Encryptor = TDESAlgorithm.CreateEncryptor();
                Results = Encryptor.TransformFinalBlock(DataToEncrypt, 0, DataToEncrypt.Length);
            }
            finally
            {
                TDESAlgorithm.Clear();
                HashProvider.Clear();
                HashProvider.Dispose();
                TDESAlgorithm.Dispose();
            }

            return Convert.ToBase64String(Results).Replace('+', '_').Replace('=', '@').Replace('/', '$');
        }
        #endregion Encrypt        

        #region ToRoman
        /// <summary>
        /// ToRoman
        /// </summary>
        /// <param name="number"></param>
        /// <returns></returns>
        public static string ToRoman(int number)
        {
            if ((number < 0) || (number > 3999)) throw new ArgumentOutOfRangeException("insert value betwheen 1 and 3999");
            if (number < 1) return string.Empty;
            if (number >= 1000) return "M" + ToRoman(number - 1000);
            if (number >= 900) return "CM" + ToRoman(number - 900);
            if (number >= 500) return "D" + ToRoman(number - 500);
            if (number >= 400) return "CD" + ToRoman(number - 400);
            if (number >= 100) return "C" + ToRoman(number - 100);
            if (number >= 90) return "XC" + ToRoman(number - 90);
            if (number >= 50) return "L" + ToRoman(number - 50);
            if (number >= 40) return "XL" + ToRoman(number - 40);
            if (number >= 10) return "X" + ToRoman(number - 10);
            if (number >= 9) return "IX" + ToRoman(number - 9);
            if (number >= 5) return "V" + ToRoman(number - 5);
            if (number >= 4) return "IV" + ToRoman(number - 4);
            if (number >= 1) return "I" + ToRoman(number - 1);
            throw new ArgumentOutOfRangeException("something bad happened");
        }
        #endregion
    }
}
